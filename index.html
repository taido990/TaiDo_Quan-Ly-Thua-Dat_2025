<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>T√†i ƒê·ªó_Map_2026</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
  <style>
    :root {
      --primary-white: #ffffff;
      --bg-light: #f8f9fa;
      --border-color: #dee2e6;
      --text-main: #343a40;
      --accent-orange: #fd7e14;
      --accent-blue: #0d6efd;
      --accent-green: #198754;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-light);
      overflow: hidden;
      color: var(--text-main);
    }

    #map {
      height: 100vh;
      width: 100%;
      z-index: 1;
      background: #eee;
    }

    #top-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      background: var(--primary-white);
      padding: 12px 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="number"],
    input[type="text"],
    input[type="file"],
    select {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    #input-vn2000,
    #input-wgs84 {
      width: 140px;
    }

    .file-box {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .file-box label {
      font-size: 10px;
      font-weight: bold;
      color: #666;
    }

    #soto,
    #sothua {
      width: 50px;
    }

    #tenchu {
      width: 100px;
    }

    .layer-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 10px;
      border-left: 1px solid #ddd;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    button {
      padding: 9px 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: 0.3s;
    }

    .btn-search {
      background: var(--accent-orange);
      color: white;
    }

    .btn-locate {
      background: var(--accent-blue);
      color: white;
    }

    .btn-clear {
      background: #e9ecef;
      color: #495057;
    }

    .btn-direction {
      background: var(--accent-green);
      color: white;
    }

    .btn-export {
      background: #6f42c1;
      color: white;
    }

    #info-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: var(--primary-white);
      padding: 12px 20px;
      display: none;
      overflow-x: auto;
      border-top: 1px solid var(--border-color);
      box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.05);
    }

    .info-container {
      display: flex;
      gap: 25px;
      align-items: center;
      min-width: max-content;
    }

    .info-item {
      display: flex;
      flex-direction: column;
    }

    .info-label {
      font-size: 11px;
      color: #6c757d;
      font-weight: 700;
      text-transform: uppercase;
    }

    .info-value {
      font-size: 15px;
      color: var(--text-main);
      font-weight: 700;
    }

    .edge-label-inner {
      background: var(--primary-white);
      border: 1.5px solid #dc3545;
      border-radius: 4px;
      padding: 2px 5px;
      font-size: 11px;
      font-weight: 800;
      color: #dc3545;
      white-space: nowrap;
    }

    .vertex-label {
      background: #0d6efd;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      border: 1px solid white;
    }

    #loading-status {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--text-main);
      color: white;
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 13px;
      display: none;
      z-index: 2000;
    }

    #btn-locate-fixed {
      position: absolute;
      bottom: 320px;
      right: 10px;
      z-index: 1000;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      border: 2px solid white;
      width: 40px;
      height: 40px;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 8px;
    }

    .leaflet-right .leaflet-control-zoom {
      margin-bottom: 160px !important;
      border: 2px solid white;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
    }

    .file-row {
      display: flex;
      gap: 10px;
    }

    @media (max-width: 768px) {
      .file-row {
        width: 100%;
      }

      .file-box {
        flex: 1;
        min-width: 0;
      }

      .file-box input {
        width: 100%;
        box-sizing: border-box;
      }

      #top-panel {
        gap: 8px;
      }

      .layer-controls {
        border-left: none;
        border-top: 1px solid #ddd;
        padding-top: 5px;
        width: 100%;
      }
    }

    /* Custom Google Maps Style Layer Control */
    .map-style-control {
      position: absolute;
      bottom: 80px;
      /* Above scale/info */
      left: 10px;
      z-index: 1000;
      font-family: Roboto, Arial, sans-serif;
    }

    .style-btn-trigger {
      width: 60px;
      height: 60px;
      background: white;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid white;
      transition: 0.2s;
      overflow: hidden;
    }

    .style-btn-trigger:hover {
      border-color: #333;
    }

    .style-btn-trigger img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .style-panel {
      position: absolute;
      bottom: 0;
      left: 70px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      display: none;
      /* Grid layout for map types */
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 300px;
    }

    .map-type-item {
      cursor: pointer;
      border-radius: 4px;
      overflow: hidden;
      border: 2px solid transparent;
      text-align: center;
    }

    .map-type-item.active {
      border-color: #333;
    }

    .map-type-item:hover {
      border-color: #ccc;
    }

    .map-type-image {
      width: 100%;
      height: 60px;
      background-color: #eee;
      border-radius: 4px;
      margin-bottom: 5px;
      background-size: cover;
      background-position: center;
    }

    .map-type-label {
      font-size: 11px;
      color: #333;
      font-weight: 500;
    }

    .show-panel {
      display: grid !important;
    }

    /* Styles for Measure Controls */
    .btn-measure {
      background: #ffc107;
      color: #212529;
    }

    .measure-active {
      background: #28a745 !important;
      color: white !important;
    }

    /* Measure label styles */
    .measure-edge-label-inner {
      background: var(--primary-white);
      border: 1.5px solid #ff0000;
      border-radius: 4px;
      padding: 2px 5px;
      font-size: 11px;
      font-weight: 800;
      color: #ff0000;
      white-space: nowrap;
    }

    .measure-area-label-inner {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #ff0000;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      font-weight: bold;
      color: #ff0000;
    }
  </style>
</head>

<body>

  <div id="loading-status">üõ∞Ô∏è ƒêang x·ª≠ l√Ω d·ªØ li·ªáu...</div>

  <button id="btn-locate-fixed" class="btn-locate" onclick="locateUser()" title="V·ªã tr√≠ c·ªßa t√¥i">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"></circle>
      <path d="M12 2v3m0 14v3M2 12h3m14 0h3"></path>
    </svg>
  </button>

  <div id="top-panel">
    <div class="file-row">
      <div class="file-box">
        <label>ƒê·ªäA CH√çNH</label>
        <input type="file" id="file-dc" accept=".geojson">
      </div>
      <div class="file-box">
        <label>QUY HO·∫†CH</label>
        <input type="file" id="file-qh" accept=".geojson">
      </div>
    </div>

    <div class="input-group" style="align-items: flex-end;">
      <div class="file-box">
        <label>T·ªàNH/TP (KTT)</label>
        <select id="sel-province"></select>
      </div>
      <button class="btn-search" onclick="searchParcel()">üîç T√åM</button>
      <button class="btn-clear" onclick="clearSearch()">‚úñ</button>
    </div>

    <div class="input-group">
      <input type="number" id="soto" placeholder="T·ªù">
      <input type="number" id="sothua" placeholder="Th·ª≠a">
      <input type="text" id="tenchu" placeholder="T√™n ch·ªß">
    </div>

    <button id="btn-toggle-coord" class="btn-search" onclick="toggleCoordPanel()"
      style="padding: 9px 12px; min-width: 40px; background: var(--accent-green);">‚ñ∂ T√¨m t·ªça ƒë·ªô</button>
    <div id="coord-panel" style="display:none; flex-direction:column; gap:5px;">
      <div class="input-group">
        <input type="text" id="input-vn2000" placeholder="VN2000: Y, X (m)">
        <button class="btn-search" onclick="searchVN2000()">üîç VN</button>
      </div>

      <div class="input-group">
        <input type="text" id="input-wgs84" placeholder="WGS84: Lat, Lng (h·ªó tr·ª£ link GMaps, DMS)">
        <button class="btn-search" onclick="searchWGS84()">üîç WGS</button>
      </div>
    </div>

    <div class="layer-controls">
      <label class="checkbox-group"><input type="checkbox" id="chk-dc" checked onchange="toggleLayer('dc')"> Hi·ªán
        ƒêC</label>
      <label class="checkbox-group"><input type="checkbox" id="chk-qh" checked onchange="toggleLayer('qh')"> Hi·ªán
        QH</label>
      <label class="checkbox-group"><input type="checkbox" id="chk-edges" checked onchange="toggleEdgesAndVertices()">
        Hi·ªán
        C·∫°nh</label>
    </div>

    <!-- Th√™m n√∫t ƒëo kho·∫£ng c√°ch v√† di·ªán t√≠ch -->
    <button id="btn-measure-distance" class="btn-measure" onclick="toggleMeasure('distance')">üìè ƒêo KC</button>
    <button id="btn-measure-area" class="btn-measure" onclick="toggleMeasure('area')">üìê ƒêo DT</button>
    <button class="btn-export" onclick="exportMeasureCoords()" style="display: none;" id="btn-export-measure">üì• Xu·∫•t Tƒê
      ƒêo</button>
    <button class="btn-clear" onclick="clearMeasure()">‚úñ X√≥a ƒêo</button>
  </div>

  <button id="btn-toggle-top" class="btn-search" onclick="toggleTopPanel()"
    style="position: absolute; top: 10px; right: 10px; z-index: 1000; padding: 9px 12px; min-width: 40px; background: var(--accent-green); color: white;">‚óÄ</button>

  <!-- Custom Layer Control UI -->
  <div class="map-style-control" onmouseenter="showLayerPanel()" onmouseleave="hideLayerPanel()">
    <div class="style-btn-trigger">
      <!-- Icon placeholder, using a simple map icon or dynamic first layer -->
      <img
        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBvbHlnb24gcG9pbnRzPSIxMiAyIDIgNyAxMiAxMiAyMiA3IDEyIDIiLz48cG9seWxpbmUgcG9pbnRzPSIyIDE3IDEyIDIyIDIyIDE3Ii8+PHBvbHlnb24gcG9pbnRzPSIyIDEyIDEyIDE3IDIyIDEyIi8+PC9zdmc+"
        alt="Layers" style="padding: 10px;">
    </div>
    <div class="style-panel" id="style-panel">
      <div class="map-type-item active" onclick="setBaseMap('Google Hybrid', this)">
        <div class="map-type-image" style="background-image: url('https://mt1.google.com/vt/lyrs=y&x=0&y=0&z=0');">
        </div>
        <div class="map-type-label">V·ªá tinh (Hybrid)</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Google Satellite', this)">
        <div class="map-type-image" style="background-image: url('https://mt1.google.com/vt/lyrs=s&x=0&y=0&z=0');">
        </div>
        <div class="map-type-label">V·ªá tinh (S·∫°ch)</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Google Streets', this)">
        <div class="map-type-image" style="background-image: url('https://mt1.google.com/vt/lyrs=m&x=0&y=0&z=0');">
        </div>
        <div class="map-type-label">ƒê∆∞·ªùng ph·ªë</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Google Terrain', this)">
        <div class="map-type-image" style="background-image: url('https://mt1.google.com/vt/lyrs=p&x=0&y=0&z=0');">
        </div>
        <div class="map-type-label">ƒê·ªãa h√¨nh</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Esri World Imagery', this)">
        <div class="map-type-image"
          style="background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/0/0/0');">
        </div>
        <div class="map-type-label">Esri Sat</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Esri World Topo', this)">
        <div class="map-type-image"
          style="background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/0/0/0');">
        </div>
        <div class="map-type-label">Esri Topo</div>
      </div>
      <div class="map-type-item" onclick="setBaseMap('Esri Hybrid', this)">
        <div class="map-type-image"
          style="background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/0/0/0');">
          <div
            style="position:absolute;top:0;left:0;right:0;bottom:0;background-image:url('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/0/0/0');pointer-events:none;">
          </div>
        </div>
        <div class="map-type-label">H·ªón h·ª£p H√¨nh ·∫£nh</div>
      </div>
    </div>
  </div>

  <div id="info-bar">
    <div class="info-container">
      <div id="info-content" style="display: flex; gap: 20px;"></div>
      <div id="direction-btn-container" style="display: flex; gap: 10px;"></div>
      <!-- Th√™m th√¥ng tin ƒëo -->
      <div id="measure-info" style="display: none; margin-left: 20px;">
        <div class="info-item">
          <span class="info-label">Kho·∫£ng C√°ch</span>
          <span class="info-value" id="measure-distance-value">0 m</span>
        </div>
        <div class="info-item">
          <span class="info-label">Di·ªán T√≠ch</span>
          <span class="info-value" id="measure-area-value">0 m¬≤</span>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script>
    const map = L.map('map', { maxZoom: 22, zoomControl: false }).setView([12.667, 108.038], 15);
    L.control.zoom({ position: 'bottomright' }).addTo(map);

    // --- C√ÅC L·ªöP N·ªÄN (BASE MAPS) ---
    const googleHybrid = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
      maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
      attribution: 'Google Hybrid'
    });

    const googleSat = L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
      attribution: 'Google Satellite'
    });

    const googleStreets = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
      maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
      attribution: 'Google Streets'
    });

    const googleTerrain = L.tileLayer('https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
      maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
      attribution: 'Google Terrain'
    });

    // Esri World Imagery
    const esriWorld = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 22,
      maxNativeZoom: 18,
      zIndex: 1,
      attribution: 'Tiles &copy; Esri'
    });

    // New Layers
    const esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 22,
      maxNativeZoom: 19,
      attribution: 'Tiles &copy; Esri'
    });

    const esriReference = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 22,
      maxNativeZoom: 18,
      zIndex: 3,
      attribution: 'Tiles &copy; Esri'
    });

    const esriTransportation = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 22,
      maxNativeZoom: 18,
      zIndex: 2,
      attribution: 'Tiles &copy; Esri'
    });

    const esriHybrid = L.layerGroup([esriWorld, esriTransportation, esriReference]);

    // M·∫∑c ƒë·ªãnh hi·ªÉn th·ªã Hybrid
    googleHybrid.addTo(map);

    const baseMaps = {
      "Google Hybrid": googleHybrid,
      "Google Satellite": googleSat,
      "Google Streets": googleStreets,
      "Google Terrain": googleTerrain,
      "Esri World Imagery": esriWorld,
      "Esri World Topo": esriTopo,
      "Esri Hybrid": esriHybrid
    };

    // REMOVED DEFAULT CONTROL
    // L.control.layers(baseMaps).addTo(map);

    function setBaseMap(name, el) {
      // Remove all base layers
      Object.keys(baseMaps).forEach(k => map.removeLayer(baseMaps[k]));
      // Add selected
      if (baseMaps[name]) baseMaps[name].addTo(map);

      // Update UI active state
      document.querySelectorAll('.map-type-item').forEach(d => d.classList.remove('active'));
      if (el) el.classList.add('active');
    }

    let dcLayer = null, qhLayer = null, highlightLayer = null;
    let dcData = null, currentSelectedFeature = null;
    let edgeLabelsLayer = L.layerGroup().addTo(map);
    let vertexLayer = L.layerGroup().addTo(map); // Layer ch·ª©a ƒë·ªânh th·ª≠a
    let measureLabelsLayer = L.layerGroup().addTo(map); // Layer cho labels ƒëo
    let currentKTT = 108.5;

    const fieldMapping = {
      "SHBANDO": "T·ªù", "SHTHUA": "Th·ª≠a", "DIENTICH": "Di·ªán t√≠ch (m¬≤)",
      "KHLOAIDAT": "Lo·∫°i ƒë·∫•t", "TENCHU": "T√™n ch·ªß"
    };

    // 1. DANH S√ÅCH 63 T·ªàNH TH√ÄNH (KTT VN2000)
    const provinces = [
      { name: "An Giang", ktt: 104.75 }, { name: "B√† R·ªãa - V≈©ng T√†u", ktt: 107.75 }, { name: "B·∫°c Li√™u", ktt: 105.00 },
      { name: "B·∫Øc K·∫°n", ktt: 106.50 }, { name: "B·∫Øc Giang", ktt: 107.00 }, { name: "B·∫Øc Ninh", ktt: 105.50 },
      { name: "B·∫øn Tre", ktt: 105.75 }, { name: "B√¨nh D∆∞∆°ng", ktt: 105.75 }, { name: "B√¨nh ƒê·ªãnh", ktt: 108.25 },
      { name: "B√¨nh Ph∆∞·ªõc", ktt: 106.25 }, { name: "B√¨nh Thu·∫≠n", ktt: 108.50 }, { name: "C√† Mau", ktt: 104.50 },
      { name: "Cao B·∫±ng", ktt: 105.75 }, { name: "C·∫ßn Th∆°", ktt: 105.00 }, { name: "ƒê√† N·∫µng", ktt: 107.75 },
      { name: "ƒê·∫Øk L·∫Øk", ktt: 108.50 }, { name: "ƒê·∫Øk N√¥ng", ktt: 108.50 }, { name: "ƒêi·ªán Bi√™n", ktt: 103.00 },
      { name: "ƒê·ªìng Nai", ktt: 107.75 }, { name: "ƒê·ªìng Th√°p", ktt: 105.00 }, { name: "Gia Lai", ktt: 108.50 },
      { name: "H√† Giang", ktt: 105.50 }, { name: "H√† Nam", ktt: 105.00 }, { name: "H√† N·ªôi", ktt: 105.00 },
      { name: "H√† Tƒ©nh", ktt: 105.50 }, { name: "H·∫£i D∆∞∆°ng", ktt: 105.50 }, { name: "H·∫£i Ph√≤ng", ktt: 105.75 },
      { name: "H·∫≠u Giang", ktt: 105.00 }, { name: "H√≤a B√¨nh", ktt: 106.00 }, { name: "TP. H·ªì Ch√≠ Minh", ktt: 105.75 },
      { name: "H∆∞ng Y√™n", ktt: 105.50 }, { name: "Kh√°nh H√≤a", ktt: 108.25 }, { name: "Ki√™n Giang", ktt: 104.50 },
      { name: "Kon Tum", ktt: 107.50 }, { name: "Lai Ch√¢u", ktt: 103.00 }, { name: "L√¢m ƒê·ªìng", ktt: 107.75 },
      { name: "L·∫°ng S∆°n", ktt: 107.25 }, { name: "L√†o Cai", ktt: 104.75 }, { name: "Long An", ktt: 105.75 },
      { name: "Nam ƒê·ªãnh", ktt: 105.50 }, { name: "Ngh·ªá An", ktt: 104.75 }, { name: "Ninh B√¨nh", ktt: 105.00 },
      { name: "Ninh Thu·∫≠n", ktt: 108.25 }, { name: "Ph√∫ Th·ªç", ktt: 104.75 }, { name: "Ph√∫ Y√™n", ktt: 108.50 },
      { name: "Qu·∫£ng B√¨nh", ktt: 106.00 }, { name: "Qu·∫£ng Nam", ktt: 107.75 }, { name: "Qu·∫£ng Ng√£i", ktt: 108.00 },
      { name: "Qu·∫£ng Ninh", ktt: 107.75 }, { name: "Qu·∫£ng Tr·ªã", ktt: 106.25 }, { name: "S√≥c TrƒÉng", ktt: 105.50 },
      { name: "S∆°n La", ktt: 104.00 }, { name: "T√¢y Ninh", ktt: 105.50 }, { name: "Th√°i B√¨nh", ktt: 105.50 },
      { name: "Th√°i Nguy√™n", ktt: 106.50 }, { name: "Thanh H√≥a", ktt: 105.00 }, { name: "Th·ª´a Thi√™n Hu·∫ø", ktt: 107.00 },
      { name: "Ti·ªÅn Giang", ktt: 105.75 }, { name: "Tr√† Vinh", ktt: 105.50 }, { name: "Tuy√™n Quang", ktt: 106.00 },
      { name: "Vƒ©nh Long", ktt: 105.50 }, { name: "Vƒ©nh Ph√∫c", ktt: 105.00 }, { name: "Y√™n B√°i", ktt: 104.75 }
    ].sort((a, b) => a.name.localeCompare(b.name));

    // Kh·ªüi t·∫°o Select Province
    const selProv = document.getElementById('sel-province');
    provinces.forEach(p => {
      let opt = new Option(`${p.name} (${p.ktt})`, p.ktt);
      if (p.name === "ƒê·∫Øk L·∫Øk") opt.selected = true;
      selProv.add(opt);
    });

    selProv.onchange = function () { updateVN2000(parseFloat(this.value)); };

    // 2. C·∫¨P NH·∫¨T H√ÄM VN2000 V·ªöI 7 THAM S·ªê V√Ä GRS80
    function updateVN2000(ktt) {
      currentKTT = ktt;
      const def = `+proj=tmerc +lat_0=0 +lon_0=${ktt} +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=-191.90441429,-39.30318279,-111.45032835,0.00928836,-0.01975479,0.00427372,0.252906278 +units=m +no_defs`;
      proj4.defs("VN2000_Current", def);
    }
    updateVN2000(currentKTT);

    // X·ª≠ l√Ω file
    document.getElementById('file-dc').onchange = e => loadFile(e.target.files[0], 'dc');
    document.getElementById('file-qh').onchange = e => loadFile(e.target.files[0], 'qh');

    function loadFile(file, type) {
      if (!file) return;
      const reader = new FileReader();
      document.getElementById('loading-status').style.display = 'block';
      reader.onload = function () {
        try {
          const json = JSON.parse(reader.result);
          type === 'dc' ? (dcData = json, renderDC(json)) : renderQH(json);
        } catch (err) { alert("L·ªói GeoJSON!"); }
        document.getElementById('loading-status').style.display = 'none';
      };
      reader.readAsText(file);
    }

    function renderDC(data) {
      if (dcLayer) map.removeLayer(dcLayer);
      dcLayer = L.geoJSON(data, {
        style: { color: "#ffeb3b", weight: 1.5, fillOpacity: 0.1 },
        onEachFeature: (f, l) => l.on('click', e => { processSelection(f, l); L.DomEvent.stopPropagation(e); })
      }).addTo(map);
      map.fitBounds(dcLayer.getBounds());
    }

    function renderQH(data) {
      if (qhLayer) map.removeLayer(qhLayer);
      qhLayer = L.geoJSON(data, {
        style: f => ({ color: "#333", weight: 0.5, fillColor: f.properties.fill || "#000", fillOpacity: f.properties["fill-opacity"] || 0.5 }),
        interactive: false
      }).addTo(map);
      if (qhLayer.getBounds().isValid()) map.fitBounds(qhLayer.getBounds());
    }

    function toggleLayer(type) {
      if (type === 'dc' && dcLayer) document.getElementById('chk-dc').checked ? map.addLayer(dcLayer) : map.removeLayer(dcLayer);
      if (type === 'qh' && qhLayer) document.getElementById('chk-qh').checked ? map.addLayer(qhLayer) : map.removeLayer(qhLayer);
    }

    function processSelection(feature, layer) {
      currentSelectedFeature = feature;
      if (highlightLayer) map.removeLayer(highlightLayer);
      highlightLayer = L.geoJSON(feature, { style: { color: "#dc3545", weight: 4, fillColor: "#0d6efd", fillOpacity: 0.2 } }).addTo(map);
      const center = layer.getBounds().getCenter();
      showInfoHorizontal(feature.properties, center.lat, center.lng);

      if (document.getElementById('chk-edges').checked) {
        updateEdges();
        const orderedPts = getOrderedVertices(feature);
        drawVertices(orderedPts);
      }

      map.fitBounds(layer.getBounds(), { padding: [100, 100] });
    }

    function updateEdges() {
      edgeLabelsLayer.clearLayers();
      if (!currentSelectedFeature) return;
      let coords = (currentSelectedFeature.geometry.type === "Polygon") ? currentSelectedFeature.geometry.coordinates[0] : currentSelectedFeature.geometry.coordinates[0][0];
      for (let i = 0; i < coords.length - 1; i++) {
        let p1 = L.latLng(coords[i][1], coords[i][0]), p2 = L.latLng(coords[i + 1][1], coords[i + 1][0]);
        let dist = p1.distanceTo(p2);
        if (dist > 0.3) {
          let mid = [(p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2];
          let rotation = -Math.atan2(p2.lat - p1.lat, p2.lng - p1.lng) * 180 / Math.PI;
          if (rotation > 90) rotation -= 180; if (rotation < -90) rotation += 180;
          L.marker(mid, {
            icon: L.divIcon({ className: 'edge-label-container', html: `<div class="edge-label-inner" style="transform: rotate(${rotation}deg);">${dist.toFixed(2)}m</div>`, iconSize: [40, 20] }), interactive: false
          }).addTo(edgeLabelsLayer);
        }
      }
    }

    function showInfoHorizontal(props, lat, lng) {
      const bar = document.getElementById('info-bar'), content = document.getElementById('info-content'), btnContainer = document.getElementById('direction-btn-container');
      bar.style.display = 'block';
      let html = "";
      Object.keys(props).forEach(key => {
        let label = fieldMapping[key] || key;
        let val = props[key];
        if (key === "SHBANDO" || key === "SHTHUA") val = Math.floor(Number(val));
        else if (key === "DIENTICH") val = Number(val).toFixed(1);
        html += `<div class="info-item"><span class="info-label">${label}</span><span class="info-value">${val || "-"}</span></div>`;
      });
      content.innerHTML = html;
      btnContainer.innerHTML = `<button class="btn-direction" onclick="window.open('https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}', '_blank')">üöó CH·ªà ƒê∆Ø·ªúNG</button>
                                <button class="btn-export" onclick="exportCoords()">üì• XU·∫§T T·ªåA ƒê·ªò</button>`;
    }

    // 3. HI·ªÇN TH·ªä T·ªåA ƒê·ªò KHI CLICK L√ÄM TR√íN 3 S·ªê
    map.on('click', function (e) {
      if (measureMode) {
        addMeasurePoint(e.latlng);
        return;
      }
      const vn2000 = proj4(proj4.defs('EPSG:4326'), proj4.defs('VN2000_Current'), [e.latlng.lng, e.latlng.lat]);
      L.popup().setLatLng(e.latlng).setContent(`
        <div style="text-align:center; font-size:13px;">
          <strong style="color:#0d6efd">üìç T·ªåA ƒê·ªò V·ªä TR√ç</strong><br>
          <div style="margin-top:5px; text-align:left;">
            <b>WGS84:</b> ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}<br>
            <b>VN2000 (KTT ${currentKTT}):</b><br>X: ${vn2000[1].toFixed(3)} | Y: ${vn2000[0].toFixed(3)}
          </div>
        </div>
      `).openOn(map);
    });

    map.on('dblclick', function (e) {
      if (measureMode) {
        finishMeasure();
      }
    });

    // H√†m x·ª≠ l√Ω logic l·∫•y v√† s·∫Øp x·∫øp ƒë·ªânh (D√πng chung cho hi·ªÉn th·ªã v√† xu·∫•t file)
    function getOrderedVertices(feature) {
      let coords = (feature.geometry.type === "Polygon") ? feature.geometry.coordinates[0] : feature.geometry.coordinates[0][0];
      // B·ªè ƒëi·ªÉm cu·ªëi tr√πng ƒëi·ªÉm ƒë·∫ßu v√† ƒê·∫£o chi·ªÅu (CCW -> CW)
      let pts = coords.slice(0, -1).reverse();

      // Chuy·ªÉn sang VN2000
      let vnPts = pts.map(p => {
        let xy = proj4(proj4.defs('EPSG:4326'), proj4.defs('VN2000_Current'), [p[0], p[1]]);
        return {
          x: xy[1], // Northing
          y: xy[0], // Easting
          lng: p[0],
          lat: p[1]
        };
      });

      // T√¨m ƒëi·ªÉm c·ª±c B·∫Øc (Max X)
      let maxIdx = 0;
      vnPts.forEach((p, i) => { if (p.x > vnPts[maxIdx].x) maxIdx = i; });

      // Xoay m·∫£ng b·∫Øt ƒë·∫ßu t·ª´ c·ª±c B·∫Øc
      return [...vnPts.slice(maxIdx), ...vnPts.slice(0, maxIdx)];
    }

    function drawVertices(orderedPts) {
      vertexLayer.clearLayers();
      orderedPts.forEach((pt, idx) => {
        const stt = idx + 1;
        // Marker s·ªë th·ª© t·ª±
        L.marker([pt.lat, pt.lng], {
          icon: L.divIcon({
            className: 'vertex-icon',
            html: `<div class="vertex-label">${stt}</div>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          }),
          interactive: false
        }).addTo(vertexLayer);
      });
    }

    // 4. XU·∫§T T·ªåA ƒê·ªò
    function exportCoords() {
      if (!currentSelectedFeature) return;

      const ordered = getOrderedVertices(currentSelectedFeature);

      let content = "STT\tX(m)\tY(m)\tZ(m)\n";
      ordered.forEach((pt, idx) => {
        content += `${idx + 1}\t${pt.x.toFixed(3)}\t${pt.y.toFixed(3)}\t0.000\n`;
      });

      const blob = new Blob([content], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `ToaDo_To_${currentSelectedFeature.properties.SHBANDO}_Thua_${currentSelectedFeature.properties.SHTHUA}.txt`;
      link.click();
    }

    function searchParcel() {
      const s = document.getElementById('soto').value.trim(), t = document.getElementById('sothua').value.trim(), n = document.getElementById('tenchu').value.trim().toLowerCase();
      if (!dcLayer) return alert("Vui l√≤ng n·∫°p file ƒê·ªãa ch√≠nh!");
      let found = null;
      dcLayer.eachLayer(l => {
        const p = l.feature.properties;
        if ((s && t && p.SHBANDO == s && p.SHTHUA == t) || (n && String(p.TENCHU || "").toLowerCase().includes(n))) found = l;
      });
      found ? processSelection(found.feature, found) : alert("Kh√¥ng t√¨m th·∫•y!");
    }

    function clearSearch() {
      ['soto', 'sothua', 'tenchu', 'input-vn2000', 'input-wgs84'].forEach(id => document.getElementById(id).value = '');
      if (highlightLayer) map.removeLayer(highlightLayer);
      if (searchMarkerFn) map.removeLayer(searchMarkerFn);
      edgeLabelsLayer.clearLayers();
      vertexLayer.clearLayers(); // X√≥a ƒë·ªânh
      document.getElementById('info-bar').style.display = 'none';
      currentSelectedFeature = null;
    }

    let searchMarkerFn = null;
    function createSearchMarker(latlng, popupContent) {
      if (searchMarkerFn) map.removeLayer(searchMarkerFn);
      searchMarkerFn = L.marker(latlng).addTo(map)
        .bindPopup(popupContent).openPopup();
      return searchMarkerFn;
    }

    function searchVN2000() {
      const val = document.getElementById('input-vn2000').value.trim();
      if (!val) return alert("Nh·∫≠p t·ªça ƒë·ªô VN2000: Y X (ho·∫∑c Y, X)!");
      // Ch·∫•p nh·∫≠n c√°ch nhau b·ªüi d·∫•u ph·∫©y ho·∫∑c kho·∫£ng tr·∫Øng
      // Format ƒë√∫ng user y√™u c·∫ßu: Y (6 s·ªë) tr∆∞·ªõc, X (7 s·ªë) sau? Hay ng∆∞·ª£c l·∫°i? 
      // Input placeholder: Y, X (m) -> T·ª©c Easting, Northing
      // Proj4 args: [Easting, Northing]

      let parts = val.split(/[,;\s]+/).map(Number).filter(n => !isNaN(n));
      if (parts.length < 2) return alert("C·∫ßn nh·∫≠p ƒë·ªß X v√† Y!");

      // Gi·∫£ s·ª≠ user nh·∫≠p Y(Easting - 6 s·ªë), X(Northing - 7 s·ªë) ho·∫∑c ng∆∞·ª£c l·∫°i.
      // Th√¥ng th∆∞·ªùng ·ªü VN, X l√† Northing (7 s·ªë), Y l√† Easting (6 s·ªë).
      // Nh∆∞ng textbox ghi "VN2000: Y, X" theo th√≥i quen tr·∫Øc ƒë·ªãa hay to√°n h·ªçc?
      // Check ƒë·ªô l·ªõn ƒë·ªÉ ƒëo√°n: X (Northing) ~ 1,000,000+, Y (Easting) ~ 400,000 - 600,000 (M√∫i 3)

      let vX = parts[0];
      let vY = parts[1];

      // Auto swap if needed based on typical VN2000 ranges for Vietnam
      // Northing (X) th∆∞·ªùng > 1,000,000 (kho·∫£ng 8-23 ƒë·ªô vƒ© b·∫Øc => 1tr - 2.5tr m√©t)
      // Easting (Y) th∆∞·ªùng 500,000 +/- 150km => 350,000 - 650,000 (·ªü d·∫°ng kh·ª≠ 500k th√¨ kh√°c, nh∆∞ng d·∫°ng chu·∫©n VN2000 th∆∞·ªùng l√† s·ªë d∆∞∆°ng l·ªõn).
      // N·∫øu user nh·∫≠p ƒë√∫ng Y(Easting), X(Northing):
      let e = vX;
      let n = vY;

      // Heuristic: N·∫øu s·ªë th·ª© 1 l·ªõn h∆°n 800,000 v√† s·ªë th·ª© 2 nh·ªè h∆°n 800,000 => Kh·∫£ nƒÉng s·ªë 1 l√† Northing (X)
      if (vX > 800000 && vY < 800000) { e = vY; n = vX; }
      else if (vY > 800000 && vX < 800000) { e = vX; n = vY; }

      // Transform
      try {
        const wgs = proj4(proj4.defs('VN2000_Current'), proj4.defs('EPSG:4326'), [e, n]);
        if (isNaN(wgs[0]) || isNaN(wgs[1])) throw "NaN";

        map.flyTo([wgs[1], wgs[0]], 18);
        createSearchMarker([wgs[1], wgs[0]], `<div style='text-align:center'><b>VN2000 Found</b><br>X: ${n}<br>Y: ${e}</div>`);
      } catch (err) {
        alert("L·ªói chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô! Ki·ªÉm tra l·∫°i s·ªë li·ªáu.");
      }
    }

    function searchWGS84() {
      const val = document.getElementById('input-wgs84').value.trim();
      if (!val) return alert("Nh·∫≠p Lat, Lng ho·∫∑c ƒë·ªãnh d·∫°ng h·ªó tr·ª£!");

      let lat, lng;

      // 1. Ki·ªÉm tra n·∫øu l√† link Google Maps (v√≠ d·ª•: https://maps.app.goo.gl/...)
      // L∆∞u √Ω: Link shortened kh√¥ng ch·ª©a tr·ª±c ti·∫øp coords, c·∫ßn extract t·ª´ pattern ho·∫∑c gi·∫£ ƒë·ªãnh user copy coords t·ª´ link.
      // ƒê·ªÉ ƒë∆°n gi·∫£n, ki·ªÉm tra n·∫øu ch·ª©a "goo.gl" ho·∫∑c "maps.app" v√† extract coords n·∫øu c√≥ pattern nh∆∞ @lat,lng
      if (val.includes('maps.app.goo.gl') || val.includes('google.com/maps')) {
        // Gi·∫£ s·ª≠ user copy full URL v·ªõi @lat,lng,... 
        const match = val.match(/@(-?[\d.,]+),(-?[\d.,]+)/);
        if (match) {
          lat = parseFloat(match[1].replace(',', '.'));
          lng = parseFloat(match[2].replace(',', '.'));
        } else {
          return alert("Link Google Maps kh√¥ng ch·ª©a t·ªça ƒë·ªô h·ª£p l·ªá! H√£y copy t·ªça ƒë·ªô tr·ª±c ti·∫øp.");
        }
      }
      // 2. Ki·ªÉm tra ƒë·ªãnh d·∫°ng ƒë·ªô ph√∫t gi√¢y (DMS): 12¬∞39'43.0"N 108¬∞01'44.9"E
      else if (val.includes('¬∞') && val.includes("'") && (val.includes('"') || val.includes('.')) && (val.includes('N') || val.includes('S')) && (val.includes('E') || val.includes('W'))) {
        const dmsRegex = /(-?\d+)¬∞(\d+)'([\d.]+)"?([NS])\s+(-?\d+)¬∞(\d+)'([\d.]+)"?([EW])/i;
        const match = val.match(dmsRegex);
        if (match) {
          const latDeg = parseInt(match[1]);
          const latMin = parseInt(match[2]);
          const latSec = parseFloat(match[3]);
          const latHem = match[4].toUpperCase();
          const lngDeg = parseInt(match[5]);
          const lngMin = parseInt(match[6]);
          const lngSec = parseFloat(match[7]);
          const lngHem = match[8].toUpperCase();

          lat = latDeg + latMin / 60 + latSec / 3600;
          if (latHem === 'S') lat = -lat;

          lng = lngDeg + lngMin / 60 + lngSec / 3600;
          if (lngHem === 'W') lng = -lng;
        } else {
          return alert("ƒê·ªãnh d·∫°ng DMS kh√¥ng h·ª£p l·ªá!");
        }
      }
      // 3. ƒê·ªãnh d·∫°ng m·∫∑c ƒë·ªãnh: lat, lng ph√¢n c√°ch b·ªüi d·∫•u ph·∫©y ho·∫∑c kho·∫£ng tr·∫Øng, h·ªó tr·ª£ d·∫•u ph·∫©y th·∫≠p ph√¢n
      else {
        // Regex ƒë·ªÉ l·∫•y hai s·ªë c√≥ th·ªÉ c√≥ d·∫•u ph·∫©y th·∫≠p ph√¢n
        const coordRegex = /([\d.,]+)[\s,;]+([\d.,]+)/;
        const match = val.match(coordRegex);
        if (match) {
          lat = parseFloat(match[1].replace(',', '.'));
          lng = parseFloat(match[2].replace(',', '.'));
        } else {
          return alert("ƒê·ªãnh d·∫°ng t·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá!");
        }
      }

      // Basic check for Vietnam bounds (Lat 8-24, Lng 102-110) just to warn, but allow map to fly anywhere
      map.flyTo([lat, lng], 18);

      // Convert ng∆∞·ª£c sang VN2000 ƒë·ªÉ hi·ªÉn th·ªã info
      const vn = proj4(proj4.defs('EPSG:4326'), proj4.defs('VN2000_Current'), [lng, lat]);
      createSearchMarker([lat, lng], `<div style='text-align:center'><b>WGS84 Location</b><br>Lat: ${lat}<br>Lng: ${lng}<br>VN2000: ${vn[1].toFixed(2)}, ${vn[0].toFixed(2)}</div>`);
    }

    function locateUser() { map.locate({ setView: true, maxZoom: 18, enableHighAccuracy: true }); }
    map.on('locationfound', e => L.circleMarker(e.latlng, { radius: 8, color: '#fff', fillColor: '#0d6efd', fillOpacity: 1, weight: 3 }).addTo(map));

    // Layer Panel Debounce Logic
    let stylePanelTimeout;
    function showLayerPanel() {
      clearTimeout(stylePanelTimeout);
      document.getElementById('style-panel').classList.add('show-panel');
    }
    function hideLayerPanel() {
      stylePanelTimeout = setTimeout(() => {
        document.getElementById('style-panel').classList.remove('show-panel');
      }, 300); // 300ms gracetime
    }

    function toggleCoordPanel() {
      const panel = document.getElementById('coord-panel');
      const btn = document.getElementById('btn-toggle-coord');
      if (panel.style.display === 'none') {
        panel.style.display = 'flex';
        btn.innerHTML = '‚óÄ T√¨m t·ªça ƒë·ªô'; // M≈©i t√™n tr√°i ƒë·ªÉ ·∫©n (theo y√™u c·∫ßu)
      } else {
        panel.style.display = 'none';
        btn.innerHTML = '‚ñ∂ T√¨m t·ªça ƒë·ªô'; // M≈©i t√™n ph·∫£i ƒë·ªÉ hi·ªán
      }
    }

    function toggleTopPanel() {
      const panel = document.getElementById('top-panel');
      const btn = document.getElementById('btn-toggle-top');
      if (panel.style.display === 'none') {
        panel.style.display = 'flex';
        btn.innerHTML = '‚óÄ';
      } else {
        panel.style.display = 'none';
        btn.innerHTML = '‚ñ∂';
      }
    }

    function toggleEdgesAndVertices() {
      const checked = document.getElementById('chk-edges').checked;
      if (checked) {
        map.addLayer(edgeLabelsLayer);
        map.addLayer(vertexLayer);
        if (currentSelectedFeature) {
          updateEdges();
          const orderedPts = getOrderedVertices(currentSelectedFeature);
          drawVertices(orderedPts);
        }
      } else {
        map.removeLayer(edgeLabelsLayer);
        map.removeLayer(vertexLayer);
      }
    }

    // Th√™m ch·ª©c nƒÉng ƒëo kho·∫£ng c√°ch v√† di·ªán t√≠ch
    let measureMode = null; // 'distance' or 'area'
    let measurePoints = []; // M·∫£ng LatLng
    let measureLayer = L.layerGroup().addTo(map); // Layer cho polyline/polygon v√† markers
    let measureDistance = 0;
    let measureArea = 0;

    function toggleMeasure(type) {
      if (measureMode === type) {
        finishMeasure();
        return;
      }
      clearMeasure();
      measureMode = type;
      document.getElementById('btn-measure-distance').classList.remove('measure-active');
      document.getElementById('btn-measure-area').classList.remove('measure-active');
      if (type === 'distance') {
        document.getElementById('btn-measure-distance').classList.add('measure-active');
      } else if (type === 'area') {
        document.getElementById('btn-measure-area').classList.add('measure-active');
      }
      document.getElementById('measure-info').style.display = 'flex';
      document.getElementById('btn-export-measure').style.display = 'inline-flex';
      alert(`Ch·∫ø ƒë·ªô ƒëo ${type === 'distance' ? 'kho·∫£ng c√°ch' : 'di·ªán t√≠ch'} ƒë√£ b·∫≠t. Click ƒë·ªÉ th√™m ƒëi·ªÉm, double click ƒë·ªÉ k·∫øt th√∫c.`);
    }

    function addMeasurePoint(latlng) {
      measurePoints.push(latlng);
      L.circleMarker(latlng, { radius: 5, color: '#ff0000' }).addTo(measureLayer);
      updateMeasure();
    }

    function updateMeasure() {
      measureLayer.clearLayers();
      measureLabelsLayer.clearLayers();
      measurePoints.forEach(pt => L.circleMarker(pt, { radius: 5, color: '#ff0000' }).addTo(measureLayer));

      if (measurePoints.length < 2) return;

      let isClosed = measureMode === 'area' && measurePoints.length >= 3 && measurePoints[0].equals(measurePoints[measurePoints.length - 1]);

      // V·∫Ω line ho·∫∑c polygon
      let drawPoints = [...measurePoints];
      if (measureMode === 'area' && isClosed) {
        L.polygon(drawPoints, { color: '#ff0000', fillColor: '#ff0000', fillOpacity: 0.3 }).addTo(measureLayer);
      } else if (measureMode === 'area') {
        L.polygon(drawPoints, { color: '#ff0000', fillColor: '#ff0000', fillOpacity: 0.3 }).addTo(measureLayer);
      } else {
        L.polyline(drawPoints, { color: '#ff0000' }).addTo(measureLayer);
      }

      // T√≠nh kho·∫£ng c√°ch
      measureDistance = 0;
      for (let i = 0; i < measurePoints.length - 1; i++) {
        let dist = measurePoints[i].distanceTo(measurePoints[i + 1]);
        measureDistance += dist;

        // Hi·ªÉn th·ªã label ƒë·ªô d√†i tr√™n c·∫°nh
        let p1 = measurePoints[i], p2 = measurePoints[i + 1];
        if (dist > 0.3) {
          let mid = [(p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2];
          let rotation = -Math.atan2(p2.lat - p1.lat, p2.lng - p1.lng) * 180 / Math.PI;
          if (rotation > 90) rotation -= 180; if (rotation < -90) rotation += 180;
          L.marker(mid, {
            icon: L.divIcon({ className: 'measure-edge-label-container', html: `<div class="measure-edge-label-inner" style="transform: rotate(${rotation}deg);">${dist.toFixed(2)}m</div>`, iconSize: [40, 20] }), interactive: false
          }).addTo(measureLabelsLayer);
        }
      }
      document.getElementById('measure-distance-value').innerText = `${measureDistance.toFixed(2)} m`;

      // T√≠nh di·ªán t√≠ch (s·ª≠ d·ª•ng shoelace formula tr√™n projected coords VN2000)
      measureArea = 0;
      if (measureMode === 'area' && measurePoints.length >= 3) {
        let calcPoints = isClosed ? measurePoints.slice(0, -1) : measurePoints;
        const projected = calcPoints.map(pt => proj4(proj4.defs('EPSG:4326'), proj4.defs('VN2000_Current'), [pt.lng, pt.lat]));
        let sum = 0;
        for (let i = 0; i < projected.length; i++) {
          const j = (i + 1) % projected.length;
          sum += (projected[i][0] * projected[j][1]) - (projected[j][0] * projected[i][1]);
        }
        measureArea = Math.abs(sum / 2);
        document.getElementById('measure-area-value').innerText = `${measureArea.toFixed(2)} m¬≤`;

        // Hi·ªÉn th·ªã label di·ªán t√≠ch b√™n trong v√πng
        if (isClosed || measurePoints.length >= 3) {
          const bounds = L.latLngBounds(calcPoints);
          const center = bounds.getCenter();
          L.marker(center, {
            icon: L.divIcon({ className: 'measure-area-label-container', html: `<div class="measure-area-label-inner">${measureArea.toFixed(2)} m¬≤</div>`, iconSize: [80, 30] }), interactive: false
          }).addTo(measureLabelsLayer);
        }

        // Hi·ªÉn th·ªã k√≠ch th∆∞·ªõc gi·ªØa ƒëi·ªÉm cu·ªëi v√† ƒëi·ªÉm ƒë·∫ßu n·∫øu ch∆∞a ƒë√≥ng
        if (!isClosed && measurePoints.length >= 3) {
          let p1 = measurePoints[measurePoints.length - 1];
          let p2 = measurePoints[0];
          let dist = p1.distanceTo(p2);
          if (dist > 0.3) {
            let mid = [(p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2];
            let rotation = -Math.atan2(p2.lat - p1.lat, p2.lng - p1.lng) * 180 / Math.PI;
            if (rotation > 90) rotation -= 180; if (rotation < -90) rotation += 180;
            L.marker(mid, {
              icon: L.divIcon({ className: 'measure-edge-label-container', html: `<div class="measure-edge-label-inner" style="transform: rotate(${rotation}deg);">${dist.toFixed(2)}m</div>`, iconSize: [40, 20] }), interactive: false
            }).addTo(measureLabelsLayer);
          }
        }
      } else {
        document.getElementById('measure-area-value').innerText = '0 m¬≤';
      }
    }

    function finishMeasure() {
      if (measureMode === 'area' && measurePoints.length >= 3 && !measurePoints[0].equals(measurePoints[measurePoints.length - 1])) {
        measurePoints.push(measurePoints[0]);
      }
      updateMeasure();
      measureMode = null;
      document.getElementById('btn-measure-distance').classList.remove('measure-active');
      document.getElementById('btn-measure-area').classList.remove('measure-active');
    }

    function clearMeasure() {
      measurePoints = [];
      measureLayer.clearLayers();
      measureLabelsLayer.clearLayers();
      measureDistance = 0;
      measureArea = 0;
      document.getElementById('measure-distance-value').innerText = '0 m';
      document.getElementById('measure-area-value').innerText = '0 m¬≤';
      document.getElementById('measure-info').style.display = 'none';
      document.getElementById('btn-export-measure').style.display = 'none';
      measureMode = null;
      document.getElementById('btn-measure-distance').classList.remove('measure-active');
      document.getElementById('btn-measure-area').classList.remove('measure-active');
    }

    function exportMeasureCoords() {
      if (measurePoints.length < 2) return alert("C·∫ßn √≠t nh·∫•t 2 ƒëi·ªÉm ƒë·ªÉ xu·∫•t!");

      let ordered = measurePoints.map(pt => {
        let xy = proj4(proj4.defs('EPSG:4326'), proj4.defs('VN2000_Current'), [pt.lng, pt.lat]);
        return { x: xy[1], y: xy[0] }; // x: Northing, y: Easting
      });

      let content = "STT\tX(m)\tY(m)\tZ(m)\n";
      ordered.forEach((pt, idx) => {
        content += `${idx + 1}\t${pt.x.toFixed(3)}\t${pt.y.toFixed(3)}\t0.000\n`;
      });

      const blob = new Blob([content], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `ToaDo_Do_${measureMode || 'Vung'}.txt`;
      link.click();
    }
  </script>
</body>

</html>
